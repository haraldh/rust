use chainerror :: * ; use serde_derive :: { { Deserialize , Serialize } } ; use serde_json ; use std :: io :: BufRead ; use std :: sync :: { { Arc , RwLock } } ; use varlink :: { { self , CallTrait } } ; # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#Enum { r#enum , r#b , r#c , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#Interface { r#interface , r#b , r#c , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#Type { r#type , r#b , r#c , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#TypeEnum { r#type , r#b , r#c , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#TypeFoo_enum { r#foo , r#bar , r#baz , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#TypeFoo_anon_baz { pub r#a : i64 , pub r#b : i64 , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#TypeFoo_anon { pub r#foo : bool , pub r#bar : i64 , pub r#baz : Vec < TypeFoo_anon_baz > , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#TypeFoo { pub r#bool : bool , pub r#int : i64 , pub r#float : f64 , pub r#string : String , pub r#enum : Option < varlink :: StringHashMap < Option < TypeFoo_enum >>> , pub r#type : Option < TypeEnum > , pub r#anon : TypeFoo_anon , pub r#object : serde_json :: Value , pub r#stringset : varlink :: StringHashSet , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct ErrorBar_Args { } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#ErrorFoo_Args_enum { pub r#b : bool , pub r#c : i64 , pub r#interface : Interface , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#ErrorFoo_Args_bar { r#type , r#enum , r#int , r#bool , r#string , r#if , r#let , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct ErrorFoo_Args { pub r#enum : ErrorFoo_Args_enum , pub r#foo : TypeFoo , pub r#bar : ErrorFoo_Args_bar , pub r#interface : Interface , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#ErrorFoo_Args_enum { pub r#b : bool , pub r#c : i64 , pub r#interface : Interface , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub enum r#ErrorFoo_Args_bar { r#type , r#enum , r#int , r#bool , r#string , r#if , r#let , } pub trait VarlinkCallError : varlink :: CallTrait { fn reply_error_bar ( & mut self , ) -> varlink :: Result < ( ) > { self . reply_struct ( varlink :: Reply :: error ( "org.example.complex.ErrorBar" , None ) ) } fn reply_error_foo ( & mut self , r#enum : ErrorFoo_Args_enum , r#foo : TypeFoo , r#bar : ErrorFoo_Args_bar , r#interface : Interface ) -> varlink :: Result < ( ) > { self . reply_struct ( varlink :: Reply :: error ( "org.example.complex.ErrorFoo" , Some ( serde_json :: to_value ( ErrorFoo_Args { r#enum , r#foo , r#bar , r#interface } ) . map_err ( minto_cherr ! ( ) ) ? ) ) ) } } impl < 'a > VarlinkCallError for varlink :: Call < 'a > { } # [ allow ( dead_code ) ] # [ derive ( Clone , PartialEq , Debug ) ] pub enum ErrorKind { Io_Error ( :: std :: io :: ErrorKind ) , SerdeJson_Error ( serde_json :: error :: Category ) , Varlink_Error , VarlinkReply_Error ( varlink :: Reply ) , Generic , ErrorBar ( Option < ErrorBar_Args > ) , ErrorFoo ( Option < ErrorFoo_Args > ) } impl :: std :: fmt :: Display for ErrorKind { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { match self { ErrorKind :: Io_Error ( _ ) => write ! ( f , "IO error" ) , ErrorKind :: SerdeJson_Error ( _ ) => { write ! ( f , "(De)Serialization Error" ) } ErrorKind :: Varlink_Error => write ! ( f , "Varlink Error" ) , ErrorKind :: VarlinkReply_Error ( v ) => write ! ( f , "Unknown error reply: '{:#?}'" , v ) , ErrorKind :: Generic => Ok ( ( ) ) , ErrorKind :: ErrorBar ( v ) => write ! ( f , "org.example.complex.ErrorBar: {:#?}" , v ) , ErrorKind :: ErrorFoo ( v ) => write ! ( f , "org.example.complex.ErrorFoo: {:#?}" , v ) } } } impl :: std :: error :: Error for ErrorKind { } impl ChainErrorFrom < std :: io :: Error > for ErrorKind { fn chain_error_from ( e : std :: io :: Error , line_filename : Option < ( u32 , & 'static str ) > , ) -> ChainError < Self > { ChainError :: < _ > :: new ( ErrorKind :: Io_Error ( e . kind ( ) ) , Some ( Box :: from ( e ) ) , line_filename ) } } impl ChainErrorFrom < serde_json :: error :: Error > for ErrorKind { fn chain_error_from ( e : serde_json :: error :: Error , line_filename : Option < ( u32 , & 'static str ) > , ) -> ChainError < Self > { ChainError :: < _ > :: new ( ErrorKind :: SerdeJson_Error ( e . classify ( ) ) , Some ( Box :: from ( e ) ) , line_filename , ) } } impl ChainErrorFrom < varlink :: ErrorKind > for ErrorKind { fn chain_error_from ( e : varlink :: ErrorKind , line_filename : Option < ( u32 , & 'static str ) > , ) -> ChainError < Self > { ChainError :: < _ > :: new ( ErrorKind :: Varlink_Error , Some ( Box :: from ( ChainError :: < _ > :: new ( e , None , line_filename , ) ) ) , line_filename , ) } } # [ allow ( dead_code ) ] pub type Result < T > = ChainResult < T , ErrorKind > ; # [ allow ( dead_code ) ] pub type Error = ErrorKind ; impl ChainErrorFrom < varlink :: Reply > for ErrorKind { # [ allow ( unused_variables ) ] fn chain_error_from ( e : varlink :: Reply , line_filename : Option < ( u32 , & 'static str ) > ) -> ChainError < Self > { if varlink :: ErrorKind :: is_error ( & e ) { let e : varlink :: ErrorKind = e . into ( ) ; return into_cherr ! ( e ) ; } match e { varlink :: Reply { error : Some ( ref t ) , .. } if t == "org.example.complex.ErrorBar" => { match e { varlink :: Reply { parameters : Some ( p ) , .. } => match serde_json :: from_value ( p ) { Ok ( v ) => into_cherr ! ( ErrorKind :: ErrorBar ( v ) ) , Err ( _ ) => into_cherr ! ( ErrorKind :: ErrorBar ( None ) ) , } , _ => into_cherr ! ( ErrorKind :: ErrorBar ( None ) ) , } } varlink :: Reply { error : Some ( ref t ) , .. } if t == "org.example.complex.ErrorFoo" => { match e { varlink :: Reply { parameters : Some ( p ) , .. } => match serde_json :: from_value ( p ) { Ok ( v ) => into_cherr ! ( ErrorKind :: ErrorFoo ( v ) ) , Err ( _ ) => into_cherr ! ( ErrorKind :: ErrorFoo ( None ) ) , } , _ => into_cherr ! ( ErrorKind :: ErrorFoo ( None ) ) , } } _ => into_cherr ! ( ErrorKind :: VarlinkReply_Error ( e ) ) , } } } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct Bar_Reply { } impl varlink :: VarlinkReply for Bar_Reply { } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct Bar_Args { } pub trait Call_Bar : VarlinkCallError { fn reply ( & mut self ) -> varlink :: Result < ( ) > { self . reply_struct ( varlink :: Reply :: parameters ( None ) ) } } impl < 'a > Call_Bar for varlink :: Call < 'a > { } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#Foo_Args_enum { pub r#b : bool , pub r#c : i64 , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct r#Foo_Reply_a { pub r#b : bool , pub r#c : i64 , } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct Foo_Reply { pub r#a : Vec < Foo_Reply_a > , pub r#foo : TypeFoo , pub r#interface : Interface , } impl varlink :: VarlinkReply for Foo_Reply { } # [ derive ( Serialize , Deserialize , Debug , PartialEq , Clone ) ] pub struct Foo_Args { pub r#enum : Foo_Args_enum , pub r#foo : TypeFoo , pub r#interface : Interface , } pub trait Call_Foo : VarlinkCallError { fn reply ( & mut self , r#a : Vec < Foo_Reply_a > , r#foo : TypeFoo , r#interface : Interface ) -> varlink :: Result < ( ) > { self . reply_struct ( Foo_Reply { r#a , r#foo , r#interface } . into ( ) ) } } impl < 'a > Call_Foo for varlink :: Call < 'a > { } pub trait VarlinkInterface { fn bar ( & self , call : & mut Call_Bar , ) -> varlink :: Result < ( ) > ; fn foo ( & self , call : & mut Call_Foo , r#enum : Foo_Args_enum , r#foo : TypeFoo , r#interface : Interface ) -> varlink :: Result < ( ) > ; fn call_upgraded ( & self , _call : & mut varlink :: Call , _bufreader : & mut BufRead ) -> varlink :: Result < Vec < u8 >> { Ok ( Vec :: new ( ) ) } } pub trait VarlinkClientInterface { fn bar ( & mut self , ) -> varlink :: MethodCall < Bar_Args , Bar_Reply , Error > ; fn foo ( & mut self , r#enum : Foo_Args_enum , r#foo : TypeFoo , r#interface : Interface ) -> varlink :: MethodCall < Foo_Args , Foo_Reply , Error > ; } # [ allow ( dead_code ) ] pub struct VarlinkClient { connection : Arc < RwLock < varlink :: Connection >> , } impl VarlinkClient { # [ allow ( dead_code ) ] pub fn new ( connection : Arc < RwLock < varlink :: Connection >> ) -> Self { VarlinkClient { connection , } } } impl VarlinkClientInterface for VarlinkClient { fn bar ( & mut self , ) -> varlink :: MethodCall < Bar_Args , Bar_Reply , Error > { varlink :: MethodCall :: < Bar_Args , Bar_Reply , Error > :: new ( self . connection . clone ( ) , "org.example.complex.Bar" , Bar_Args { } ) } fn foo ( & mut self , r#enum : Foo_Args_enum , r#foo : TypeFoo , r#interface : Interface ) -> varlink :: MethodCall < Foo_Args , Foo_Reply , Error > { varlink :: MethodCall :: < Foo_Args , Foo_Reply , Error > :: new ( self . connection . clone ( ) , "org.example.complex.Foo" , Foo_Args { r#enum , r#foo , r#interface } ) } } # [ allow ( dead_code ) ] pub struct VarlinkInterfaceProxy { inner : Box < VarlinkInterface + Send + Sync > , } # [ allow ( dead_code ) ] pub fn new ( inner : Box < VarlinkInterface + Send + Sync > ) -> VarlinkInterfaceProxy { VarlinkInterfaceProxy { inner } } impl varlink :: Interface for VarlinkInterfaceProxy { fn get_description ( & self ) -> & 'static str { "interface org.example.complex\n\ntype Enum (enum, b, c)\n\ntype Type (type, b, c)\n\ntype TypeEnum (type, b, c)\n\ntype Interface (interface, b, c)\n\ntype TypeFoo (\n  bool: bool,\n  int: int,\n  float: float,\n  string: string,\n  enum: ?[string]?(foo, bar, baz),\n  type: ?TypeEnum,\n  anon: (\n    foo: bool,\n    bar: int,\n    baz: [](a: int, b: int)\n  ),\n  object: object,\n  stringset: [string]()\n)\n\nmethod Foo(\n  enum: (b: bool, c: int),\n  foo: TypeFoo,\n  interface: Interface\n) -> (\n  a: [](b: bool, c: int),\n  foo: TypeFoo,\n  interface: Interface\n)\n\nmethod Bar() -> ()\n\nerror ErrorFoo (\n  enum: (\n    b: bool,\n    c: int,\n    interface: Interface\n  ),\n  foo: TypeFoo,\n  bar: (type, enum, int, bool, string, if, let),\n  interface: Interface\n)\n\nerror ErrorBar ()\n" } fn get_name ( & self ) -> & 'static str { "org.example.complex" } fn call_upgraded ( & self , call : & mut varlink :: Call , bufreader : & mut BufRead ) -> varlink :: Result < Vec < u8 >> { self . inner . call_upgraded ( call , bufreader ) } fn call ( & self , call : & mut varlink :: Call ) -> varlink :: Result < ( ) > { let req = call . request . unwrap ( ) ; match req . method . as_ref ( ) { "org.example.complex.Bar" => self . inner . bar ( call as & mut Call_Bar ) , "org.example.complex.Foo" => { if let Some ( args ) = req . parameters . clone ( ) { let args : Foo_Args = match serde_json :: from_value ( args ) { Ok ( v ) => v , Err ( e ) => { let es = format ! ( "{}" , e ) ; let _ = call . reply_invalid_parameter ( es . clone ( ) ) ; return Err ( into_cherr ! ( varlink :: ErrorKind :: SerdeJsonDe ( es ) ) ) ; } } ; self . inner . foo ( call as & mut Call_Foo , args . r#enum , args . r#foo , args . r#interface ) } else { call . reply_invalid_parameter ( "parameters" . into ( ) ) } } , m => { call . reply_method_not_found ( String :: from ( m ) ) } } } }